"""update_resource_state_enum_and_default

Revision ID: 7db9c2a697c1
Revises: e6d2bffdd1ee
Create Date: 2025-05-29 12:57:07.039704

"""

from typing import Sequence, Union

import sqlalchemy as sa
from alembic import op
from cmp_core.models.resource import ResourceState  # Ensure this is imported
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision: str = "7db9c2a697c1"
down_revision: Union[str, None] = "e6d2bffdd1ee"
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None

enum_name = "resourcestate"
# Get values directly from your Python Enum (these are lowercase, e.g., "pending_provision")
target_enum_values = tuple(rs.value for rs in ResourceState)

# This SQLAlchemy Enum object is used for type checking and defining the column type
# It should also use the lowercase values.
new_resource_state_sa_enum = sa.Enum(
    *target_enum_values,  # Use the lowercase values
    name=enum_name,
    create_type=False,  # We manage type creation/alteration manually
)


def upgrade() -> None:
    """Upgrade schema."""
    # Existing autogenerated changes (keep if they are intended)
    op.alter_column(
        "audit_events",
        "details",
        existing_type=postgresql.JSON(astext_type=sa.Text()),
        nullable=False,
    )
    op.alter_column(
        "resources",
        "meta",
        existing_type=postgresql.JSON(astext_type=sa.Text()),
        nullable=False,
    )

    # --- Manually added/adjusted changes for resources.state ---
    conn = op.get_bind()

    # Check if the ENUM type exists in the database
    type_exists_query = sa.text(
        f"SELECT EXISTS (SELECT 1 FROM pg_type WHERE typname = '{enum_name}');"
    )
    type_exists = conn.execute(type_exists_query).scalar_one()

    if not type_exists:
        # If the type doesn't exist, create it with all target values (lowercase)
        # Corrected f-string for SQL list
        enum_labels_sql = ", ".join([f"'{val}'" for val in target_enum_values])
        create_type_sql = f"CREATE TYPE {enum_name} AS ENUM ({enum_labels_sql});"
        op.execute(create_type_sql)
    else:
        # If the type exists, get its current labels from the DB
        existing_values_query = sa.text(
            f"SELECT unnest(enum_range(NULL::{enum_name}))::text AS val;"
        )
        result = conn.execute(existing_values_query)
        # The DB labels are already lowercase as per your psql output
        db_enum_labels = {row[0] for row in result}

        # Add any target values (lowercase) that are not already in the DB ENUM
        for value_to_add in target_enum_values:  # These are lowercase
            if value_to_add not in db_enum_labels:
                op.execute(
                    f"ALTER TYPE {enum_name} ADD VALUE IF NOT EXISTS '{value_to_add}';"
                )

        # ***** TRY TO COMMIT CHANGES TO ENUM TYPE *****
        # This is only safe if you are NOT in a transaction managed by Alembic for the whole migration.
        # If transactional_ddl = False is set at the top of the file and respected by env.py,
        # this explicit commit might not be needed or could even cause issues.
        # Test carefully.
        op.execute("COMMIT;")  # <--- Add this line

    # Alter the column to use the ENUM type.
    # The `new_resource_state_sa_enum` uses the lowercase values, matching the DB.
    op.alter_column(
        "resources",
        "state",
        type_=new_resource_state_sa_enum,  # This now uses lowercase values
        existing_type=postgresql.ENUM(
            name=enum_name, create_type=False
        ),  # Assuming it was already this enum name
        nullable=False,
        postgresql_using=f"state::text::{enum_name}",  # Cast existing values
    )

    # Set the server default using the lowercase value from your Python Enum
    op.alter_column(
        "resources",
        "state",
        server_default=sa.text(
            f"'{ResourceState.PENDING_PROVISION.value}'"
        ),  # e.g., "'pending_provision'"
    )


def downgrade() -> None:
    """Downgrade schema."""
    # Revert server_default
    op.alter_column(
        "resources", "state", server_default=None
    )  # Or set to old default if known ('creating'?)

    # This part is tricky for ENUMs. For simplicity, we might just alter the type
    # back to what it was if known, or to TEXT. Removing ENUM values is problematic.
    # For now, let's assume the old default was 'creating' and the type was 'resourcestate'
    # with its old set of values.
    # A full revert would involve restoring the old enum definition.
    # old_enum_sa = sa.Enum('creating', 'running', 'stopped', 'terminated', 'error', 'pending', 'terminating', name=enum_name, create_type=False)
    # op.alter_column(
    #     'resources',
    #     'state',
    #     type_=old_enum_sa, # This would be the old definition
    #     existing_type=new_resource_state_sa_enum,
    #     postgresql_using=f'state::text::{enum_name}'
    # )
    # For a simpler downgrade, you might remove the default and leave the ENUM type as is,
    # or change the column to TEXT if absolutely necessary.

    # Revert autogenerated changes
    op.alter_column(
        "resources",
        "meta",
        existing_type=postgresql.JSON(astext_type=sa.Text()),
        nullable=True,
    )
    op.alter_column(
        "audit_events",
        "details",
        existing_type=postgresql.JSON(astext_type=sa.Text()),
        nullable=True,
    )

    # Dropping the type on downgrade is risky if other things depend on it
    # or if you didn't create it in *this* migration's upgrade path.
    # For now, let's not drop the type in downgrade unless we are certain.
